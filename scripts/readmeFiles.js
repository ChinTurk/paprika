#!/usr/bin/env node
const fs = require("fs");
// eslint-disable-next-line import/no-extraneous-dependencies
const shell = require("shelljs");
// eslint-disable-next-line import/no-extraneous-dependencies
const reactDocs = require("react-docgen");

const skipPackages = ["helpers", "Stylers", "Tokens"];

const githubIssueBody = encodeURIComponent(`
# Help wanted

## Please write your question.
*A clear and concise description of what the question is*

## Additional context
*Add any other context or screenshots about your question here.*
`);

const renderReadmeTemplate = ({
  displayName = "",
  name = "",
  description = "** require description **",
  content = "** require content **",
  props = "",
}) => {
  return `
<!-- autogenerated don't modify -->

# ${name}

${description}

## Installation

\`\`\`
yarn add ${name}
\`\`\`

or with npm:

\`\`\`
npm install ${name}
\`\`\`

## Props 
${props}

## Usage
<!-- autogenerated don't modify -->
<!-- content -->
${content}
<!-- eoContent -->

### ref:
- [Storybook showcase:](https://paprika.highbond.com/?path=/story/${name.split("/")[1].toLowerCase()}--showcase)
- [Github source code:](https://github.com/acl-services/paprika/tree/master/packages/${displayName}/src)
- [Github create issue:](https://github.com/acl-services/paprika/issues/new?label=[]&title=${name}%20[help]:%20your%20short%20description&body=${githubIssueBody})
`;
};

const initAutoReadme = ({ path, content }) => {
  fs.writeFileSync(
    `${path}/README.md`,
    `<!-- content -->
${content}
<!-- eoContent -->
      `,
    "utf8"
  );
};

const createPropsTable = ({ info }) => {
  const table = [
    `### ${info.displayName} \n`,
    "| Prop  | Type  | required  | default   | Description |\n",
    "|-------|-------| --------  | --------- | ----------- |\n",
  ];

  Object.keys(info.props).map(key => {
    const v = info.props[key];
    return table.push(
      `|${key}|${v.type.name === "enum" ? v.type.value : v.type.name}|${v.required.toString()}|${
        v.defaultValue ? v.defaultValue.value : "-"
      }| ${v.description}|\n`
    );
  });

  return table.join("");
};

const extractCorrectComponentDefinition = ({ desireDefinition, arrayOfComponentsDefinitions }) => {
  const definition = arrayOfComponentsDefinitions.filter(def => def.displayName === desireDefinition);
  return definition[0];
};

const processPropTables = ({ info, folder, path, paprikaDocs = null }) => {
  console.log("processing", folder);
  const propsTable = [];
  // const autoGeneratedContent = readmeTemplate({ name, description, content: contentExtracted });

  propsTable.push(createPropsTable({ info }));

  // you can define on packages.json a property named paprikaDocs with an attribute subComponent to list
  // extra component that you might want to create and render on the table.
  if (paprikaDocs && "subComponents" in paprikaDocs) {
    paprikaDocs.subComponents.map(subComponent => {
      const subComponentContent = fs.readFileSync(`${path}/src/components/${subComponent}/${subComponent}.js`, "utf8");
      const subComponentInfo = reactDocs.parse(subComponentContent, reactDocs.resolver.findAllComponentDefinitions);

      propsTable.push(createPropsTable({ info: subComponentInfo }));
    });
  }

  return propsTable;
};

shell.ls("packages").forEach(folder => {
  try {
    if (!skipPackages.includes(folder)) {
      const path = `./packages/${folder}`;

      // data from package.json
      const { paprikaDocs = null, name, description = "required description" } = JSON.parse(
        fs.readFileSync(`${path}/package.json`, "utf8")
      );

      const content = fs.readFileSync(`${path}/README.md`, "utf8");
      const componentContent = fs.readFileSync(`${path}/src/${folder}.js`, "utf8");
      const arrayOfComponentsDefinitions = reactDocs.parse(
        componentContent,
        reactDocs.resolver.findAllComponentDefinitions
      );

      const info = extractCorrectComponentDefinition({ desireDefinition: folder, arrayOfComponentsDefinitions });

      if (content.search(/^<!-- content/g) >= 0) {
        // the .md file has the content tag, let's extract the content
        const contentExtracted = content.match(/<!-- content -->[\s\S]*?<!-- eoContent -->/g);
        const propTables = processPropTables({
          info,
          componentContent,
          path,
          paprikaDocs,
          folder,
          content,
        });

        const template = renderReadmeTemplate({
          displayName: info.displayName,
          name,
          description,
          content: contentExtracted,
          props: propTables.join("\n\n"),
        });

        fs.writeFileSync(`${path}/README.md`, template, { encoding: "utf8", flag: "w" });
        return;
      }

      initAutoReadme({ path, content });
    }
  } catch (error) {
    console.log(`can't process ${folder} \n\n${error}`);
  }
});
